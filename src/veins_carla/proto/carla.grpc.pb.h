// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: carla.proto
#ifndef GRPC_carla_2eproto__INCLUDED
#define GRPC_carla_2eproto__INCLUDED

#include "carla.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace carla {

class CarlaAdapter final {
public:
    static constexpr char const* service_full_name()
    {
        return "carla.CarlaAdapter";
    }
    class StubInterface {
    public:
        virtual ~StubInterface() {}
        virtual ::grpc::Status ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncExecuteOneTimeStepRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncExecuteOneTimeStepRaw(context, request, cq));
        }
        virtual ::grpc::Status Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncFinish(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncFinishRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncFinish(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncFinishRaw(context, request, cq));
        }
        virtual ::grpc::Status GetManagedActorsIds(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::carla::ActorIds* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::ActorIds>> AsyncGetManagedActorsIds(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::ActorIds>>(AsyncGetManagedActorsIdsRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::ActorIds>> PrepareAsyncGetManagedActorsIds(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::ActorIds>>(PrepareAsyncGetManagedActorsIdsRaw(context, request, cq));
        }
        virtual ::grpc::Status GetManagedActorById(::grpc::ClientContext* context, const ::carla::Number& request, ::carla::Vehicle* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::Vehicle>> AsyncGetManagedActorById(::grpc::ClientContext* context, const ::carla::Number& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::Vehicle>>(AsyncGetManagedActorByIdRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::Vehicle>> PrepareAsyncGetManagedActorById(::grpc::ClientContext* context, const ::carla::Number& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::Vehicle>>(PrepareAsyncGetManagedActorByIdRaw(context, request, cq));
        }
        virtual ::grpc::Status InsertVehicle(::grpc::ClientContext* context, const ::carla::Vehicle& request, ::carla::Number* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::Number>> AsyncInsertVehicle(::grpc::ClientContext* context, const ::carla::Vehicle& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::Number>>(AsyncInsertVehicleRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::Number>> PrepareAsyncInsertVehicle(::grpc::ClientContext* context, const ::carla::Vehicle& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::Number>>(PrepareAsyncInsertVehicleRaw(context, request, cq));
        }
        virtual ::grpc::Status GetRandomSpawnPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::carla::Transform* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::Transform>> AsyncGetRandomSpawnPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::Transform>>(AsyncGetRandomSpawnPointRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::Transform>> PrepareAsyncGetRandomSpawnPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::carla::Transform>>(PrepareAsyncGetRandomSpawnPointRaw(context, request, cq));
        }
        class experimental_async_interface {
        public:
            virtual ~experimental_async_interface() {}
            virtual void ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void GetManagedActorsIds(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::carla::ActorIds* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void GetManagedActorsIds(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::carla::ActorIds* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void GetManagedActorsIds(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::carla::ActorIds* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void GetManagedActorById(::grpc::ClientContext* context, const ::carla::Number* request, ::carla::Vehicle* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void GetManagedActorById(::grpc::ClientContext* context, const ::carla::Number* request, ::carla::Vehicle* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void GetManagedActorById(::grpc::ClientContext* context, const ::carla::Number* request, ::carla::Vehicle* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void InsertVehicle(::grpc::ClientContext* context, const ::carla::Vehicle* request, ::carla::Number* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void InsertVehicle(::grpc::ClientContext* context, const ::carla::Vehicle* request, ::carla::Number* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void InsertVehicle(::grpc::ClientContext* context, const ::carla::Vehicle* request, ::carla::Number* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void GetRandomSpawnPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::carla::Transform* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void GetRandomSpawnPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::carla::Transform* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void GetRandomSpawnPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::carla::Transform* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
        };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        async_interface* async() { return experimental_async(); }
    #endif
        virtual class experimental_async_interface* experimental_async() { return nullptr; }
    private:
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncExecuteOneTimeStepRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncExecuteOneTimeStepRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncFinishRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncFinishRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::carla::ActorIds>* AsyncGetManagedActorsIdsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::carla::ActorIds>* PrepareAsyncGetManagedActorsIdsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::carla::Vehicle>* AsyncGetManagedActorByIdRaw(::grpc::ClientContext* context, const ::carla::Number& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::carla::Vehicle>* PrepareAsyncGetManagedActorByIdRaw(::grpc::ClientContext* context, const ::carla::Number& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::carla::Number>* AsyncInsertVehicleRaw(::grpc::ClientContext* context, const ::carla::Vehicle& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::carla::Number>* PrepareAsyncInsertVehicleRaw(::grpc::ClientContext* context, const ::carla::Vehicle& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::carla::Transform>* AsyncGetRandomSpawnPointRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::carla::Transform>* PrepareAsyncGetRandomSpawnPointRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    };
    class Stub final : public StubInterface {
    public:
        Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
        ::grpc::Status ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncExecuteOneTimeStepRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncExecuteOneTimeStepRaw(context, request, cq));
        }
        ::grpc::Status Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncFinish(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncFinishRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncFinish(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncFinishRaw(context, request, cq));
        }
        ::grpc::Status GetManagedActorsIds(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::carla::ActorIds* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::ActorIds>> AsyncGetManagedActorsIds(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::ActorIds>>(AsyncGetManagedActorsIdsRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::ActorIds>> PrepareAsyncGetManagedActorsIds(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::ActorIds>>(PrepareAsyncGetManagedActorsIdsRaw(context, request, cq));
        }
        ::grpc::Status GetManagedActorById(::grpc::ClientContext* context, const ::carla::Number& request, ::carla::Vehicle* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::Vehicle>> AsyncGetManagedActorById(::grpc::ClientContext* context, const ::carla::Number& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::Vehicle>>(AsyncGetManagedActorByIdRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::Vehicle>> PrepareAsyncGetManagedActorById(::grpc::ClientContext* context, const ::carla::Number& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::Vehicle>>(PrepareAsyncGetManagedActorByIdRaw(context, request, cq));
        }
        ::grpc::Status InsertVehicle(::grpc::ClientContext* context, const ::carla::Vehicle& request, ::carla::Number* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::Number>> AsyncInsertVehicle(::grpc::ClientContext* context, const ::carla::Vehicle& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::Number>>(AsyncInsertVehicleRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::Number>> PrepareAsyncInsertVehicle(::grpc::ClientContext* context, const ::carla::Vehicle& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::Number>>(PrepareAsyncInsertVehicleRaw(context, request, cq));
        }
        ::grpc::Status GetRandomSpawnPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::carla::Transform* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::Transform>> AsyncGetRandomSpawnPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::Transform>>(AsyncGetRandomSpawnPointRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::Transform>> PrepareAsyncGetRandomSpawnPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::carla::Transform>>(PrepareAsyncGetRandomSpawnPointRaw(context, request, cq));
        }
        class experimental_async final :
            public StubInterface::experimental_async_interface {
        public:
            void ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void GetManagedActorsIds(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::carla::ActorIds* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void GetManagedActorsIds(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::carla::ActorIds* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void GetManagedActorsIds(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::carla::ActorIds* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void GetManagedActorById(::grpc::ClientContext* context, const ::carla::Number* request, ::carla::Vehicle* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void GetManagedActorById(::grpc::ClientContext* context, const ::carla::Number* request, ::carla::Vehicle* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void GetManagedActorById(::grpc::ClientContext* context, const ::carla::Number* request, ::carla::Vehicle* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void InsertVehicle(::grpc::ClientContext* context, const ::carla::Vehicle* request, ::carla::Number* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void InsertVehicle(::grpc::ClientContext* context, const ::carla::Vehicle* request, ::carla::Number* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void InsertVehicle(::grpc::ClientContext* context, const ::carla::Vehicle* request, ::carla::Number* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void GetRandomSpawnPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::carla::Transform* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void GetRandomSpawnPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::carla::Transform* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void GetRandomSpawnPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::carla::Transform* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
        private:
            friend class Stub;
            explicit experimental_async(Stub* stub)
                : stub_(stub) { }
            Stub* stub() { return stub_; }
            Stub* stub_;
        };
        class experimental_async_interface* experimental_async() override { return &async_stub_; }

    private:
        std::shared_ptr< ::grpc::ChannelInterface> channel_;
        class experimental_async async_stub_ {
            this
        };
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncExecuteOneTimeStepRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncExecuteOneTimeStepRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncFinishRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncFinishRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::carla::ActorIds>* AsyncGetManagedActorsIdsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::carla::ActorIds>* PrepareAsyncGetManagedActorsIdsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::carla::Vehicle>* AsyncGetManagedActorByIdRaw(::grpc::ClientContext* context, const ::carla::Number& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::carla::Vehicle>* PrepareAsyncGetManagedActorByIdRaw(::grpc::ClientContext* context, const ::carla::Number& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::carla::Number>* AsyncInsertVehicleRaw(::grpc::ClientContext* context, const ::carla::Vehicle& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::carla::Number>* PrepareAsyncInsertVehicleRaw(::grpc::ClientContext* context, const ::carla::Vehicle& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::carla::Transform>* AsyncGetRandomSpawnPointRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::carla::Transform>* PrepareAsyncGetRandomSpawnPointRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        const ::grpc::internal::RpcMethod rpcmethod_ExecuteOneTimeStep_;
        const ::grpc::internal::RpcMethod rpcmethod_Finish_;
        const ::grpc::internal::RpcMethod rpcmethod_GetManagedActorsIds_;
        const ::grpc::internal::RpcMethod rpcmethod_GetManagedActorById_;
        const ::grpc::internal::RpcMethod rpcmethod_InsertVehicle_;
        const ::grpc::internal::RpcMethod rpcmethod_GetRandomSpawnPoint_;
    };
    static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

    class Service : public ::grpc::Service {
    public:
        Service();
        virtual ~Service();
        virtual ::grpc::Status ExecuteOneTimeStep(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
        virtual ::grpc::Status Finish(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
        virtual ::grpc::Status GetManagedActorsIds(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::carla::ActorIds* response);
        virtual ::grpc::Status GetManagedActorById(::grpc::ServerContext* context, const ::carla::Number* request, ::carla::Vehicle* response);
        virtual ::grpc::Status InsertVehicle(::grpc::ServerContext* context, const ::carla::Vehicle* request, ::carla::Number* response);
        virtual ::grpc::Status GetRandomSpawnPoint(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::carla::Transform* response);
    };
    template <class BaseClass>
    class WithAsyncMethod_ExecuteOneTimeStep : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_ExecuteOneTimeStep()
        {
            ::grpc::Service::MarkMethodAsync(0);
        }
        ~WithAsyncMethod_ExecuteOneTimeStep() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status ExecuteOneTimeStep(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestExecuteOneTimeStep(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_Finish : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_Finish()
        {
            ::grpc::Service::MarkMethodAsync(1);
        }
        ~WithAsyncMethod_Finish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Finish(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestFinish(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_GetManagedActorsIds : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_GetManagedActorsIds()
        {
            ::grpc::Service::MarkMethodAsync(2);
        }
        ~WithAsyncMethod_GetManagedActorsIds() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedActorsIds(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::ActorIds* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestGetManagedActorsIds(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::carla::ActorIds>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_GetManagedActorById : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_GetManagedActorById()
        {
            ::grpc::Service::MarkMethodAsync(3);
        }
        ~WithAsyncMethod_GetManagedActorById() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedActorById(::grpc::ServerContext* /*context*/, const ::carla::Number* /*request*/, ::carla::Vehicle* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestGetManagedActorById(::grpc::ServerContext* context, ::carla::Number* request, ::grpc::ServerAsyncResponseWriter< ::carla::Vehicle>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_InsertVehicle : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_InsertVehicle()
        {
            ::grpc::Service::MarkMethodAsync(4);
        }
        ~WithAsyncMethod_InsertVehicle() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertVehicle(::grpc::ServerContext* /*context*/, const ::carla::Vehicle* /*request*/, ::carla::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestInsertVehicle(::grpc::ServerContext* context, ::carla::Vehicle* request, ::grpc::ServerAsyncResponseWriter< ::carla::Number>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_GetRandomSpawnPoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_GetRandomSpawnPoint()
        {
            ::grpc::Service::MarkMethodAsync(5);
        }
        ~WithAsyncMethod_GetRandomSpawnPoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetRandomSpawnPoint(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::Transform* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestGetRandomSpawnPoint(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::carla::Transform>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    typedef WithAsyncMethod_ExecuteOneTimeStep<WithAsyncMethod_Finish<WithAsyncMethod_GetManagedActorsIds<WithAsyncMethod_GetManagedActorById<WithAsyncMethod_InsertVehicle<WithAsyncMethod_GetRandomSpawnPoint<Service>>>>>> AsyncService;
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_ExecuteOneTimeStep : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_ExecuteOneTimeStep()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(0,
                new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->ExecuteOneTimeStep(context, request, response); }));
        }
        void SetMessageAllocatorFor_ExecuteOneTimeStep(
            ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_ExecuteOneTimeStep() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status ExecuteOneTimeStep(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* ExecuteOneTimeStep(
            ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* ExecuteOneTimeStep(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_Finish : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_Finish()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(1,
                new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->Finish(context, request, response); }));
        }
        void SetMessageAllocatorFor_Finish(
            ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_Finish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Finish(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* Finish(
            ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* Finish(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_GetManagedActorsIds : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_GetManagedActorsIds()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(2,
                new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::carla::ActorIds>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::google::protobuf::Empty* request, ::carla::ActorIds* response) { return this->GetManagedActorsIds(context, request, response); }));
        }
        void SetMessageAllocatorFor_GetManagedActorsIds(
            ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::carla::ActorIds>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::carla::ActorIds>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_GetManagedActorsIds() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedActorsIds(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::ActorIds* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* GetManagedActorsIds(
            ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::ActorIds* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* GetManagedActorsIds(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::ActorIds* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_GetManagedActorById : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_GetManagedActorById()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(3,
                new ::grpc::internal::CallbackUnaryHandler< ::carla::Number, ::carla::Vehicle>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::carla::Number* request, ::carla::Vehicle* response) { return this->GetManagedActorById(context, request, response); }));
        }
        void SetMessageAllocatorFor_GetManagedActorById(
            ::grpc::experimental::MessageAllocator< ::carla::Number, ::carla::Vehicle>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::carla::Number, ::carla::Vehicle>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_GetManagedActorById() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedActorById(::grpc::ServerContext* /*context*/, const ::carla::Number* /*request*/, ::carla::Vehicle* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* GetManagedActorById(
            ::grpc::CallbackServerContext* /*context*/, const ::carla::Number* /*request*/, ::carla::Vehicle* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* GetManagedActorById(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::carla::Number* /*request*/, ::carla::Vehicle* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_InsertVehicle : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_InsertVehicle()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(4,
                new ::grpc::internal::CallbackUnaryHandler< ::carla::Vehicle, ::carla::Number>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::carla::Vehicle* request, ::carla::Number* response) { return this->InsertVehicle(context, request, response); }));
        }
        void SetMessageAllocatorFor_InsertVehicle(
            ::grpc::experimental::MessageAllocator< ::carla::Vehicle, ::carla::Number>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::carla::Vehicle, ::carla::Number>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_InsertVehicle() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertVehicle(::grpc::ServerContext* /*context*/, const ::carla::Vehicle* /*request*/, ::carla::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* InsertVehicle(
            ::grpc::CallbackServerContext* /*context*/, const ::carla::Vehicle* /*request*/, ::carla::Number* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* InsertVehicle(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::carla::Vehicle* /*request*/, ::carla::Number* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_GetRandomSpawnPoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_GetRandomSpawnPoint()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(5,
                new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::carla::Transform>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::google::protobuf::Empty* request, ::carla::Transform* response) { return this->GetRandomSpawnPoint(context, request, response); }));
        }
        void SetMessageAllocatorFor_GetRandomSpawnPoint(
            ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::carla::Transform>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::carla::Transform>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_GetRandomSpawnPoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetRandomSpawnPoint(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::Transform* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* GetRandomSpawnPoint(
            ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::Transform* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* GetRandomSpawnPoint(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::Transform* /*response*/)
    #endif
        { return nullptr; }
    };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef ExperimentalWithCallbackMethod_ExecuteOneTimeStep<ExperimentalWithCallbackMethod_Finish<ExperimentalWithCallbackMethod_GetManagedActorsIds<ExperimentalWithCallbackMethod_GetManagedActorById<ExperimentalWithCallbackMethod_InsertVehicle<ExperimentalWithCallbackMethod_GetRandomSpawnPoint<Service>>>>>> CallbackService;
  #endif

    typedef ExperimentalWithCallbackMethod_ExecuteOneTimeStep<ExperimentalWithCallbackMethod_Finish<ExperimentalWithCallbackMethod_GetManagedActorsIds<ExperimentalWithCallbackMethod_GetManagedActorById<ExperimentalWithCallbackMethod_InsertVehicle<ExperimentalWithCallbackMethod_GetRandomSpawnPoint<Service>>>>>> ExperimentalCallbackService;
    template <class BaseClass>
    class WithGenericMethod_ExecuteOneTimeStep : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_ExecuteOneTimeStep()
        {
            ::grpc::Service::MarkMethodGeneric(0);
        }
        ~WithGenericMethod_ExecuteOneTimeStep() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status ExecuteOneTimeStep(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_Finish : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_Finish()
        {
            ::grpc::Service::MarkMethodGeneric(1);
        }
        ~WithGenericMethod_Finish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Finish(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_GetManagedActorsIds : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_GetManagedActorsIds()
        {
            ::grpc::Service::MarkMethodGeneric(2);
        }
        ~WithGenericMethod_GetManagedActorsIds() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedActorsIds(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::ActorIds* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_GetManagedActorById : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_GetManagedActorById()
        {
            ::grpc::Service::MarkMethodGeneric(3);
        }
        ~WithGenericMethod_GetManagedActorById() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedActorById(::grpc::ServerContext* /*context*/, const ::carla::Number* /*request*/, ::carla::Vehicle* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_InsertVehicle : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_InsertVehicle()
        {
            ::grpc::Service::MarkMethodGeneric(4);
        }
        ~WithGenericMethod_InsertVehicle() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertVehicle(::grpc::ServerContext* /*context*/, const ::carla::Vehicle* /*request*/, ::carla::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_GetRandomSpawnPoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_GetRandomSpawnPoint()
        {
            ::grpc::Service::MarkMethodGeneric(5);
        }
        ~WithGenericMethod_GetRandomSpawnPoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetRandomSpawnPoint(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::Transform* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithRawMethod_ExecuteOneTimeStep : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_ExecuteOneTimeStep()
        {
            ::grpc::Service::MarkMethodRaw(0);
        }
        ~WithRawMethod_ExecuteOneTimeStep() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status ExecuteOneTimeStep(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestExecuteOneTimeStep(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_Finish : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_Finish()
        {
            ::grpc::Service::MarkMethodRaw(1);
        }
        ~WithRawMethod_Finish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Finish(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestFinish(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_GetManagedActorsIds : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_GetManagedActorsIds()
        {
            ::grpc::Service::MarkMethodRaw(2);
        }
        ~WithRawMethod_GetManagedActorsIds() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedActorsIds(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::ActorIds* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestGetManagedActorsIds(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_GetManagedActorById : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_GetManagedActorById()
        {
            ::grpc::Service::MarkMethodRaw(3);
        }
        ~WithRawMethod_GetManagedActorById() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedActorById(::grpc::ServerContext* /*context*/, const ::carla::Number* /*request*/, ::carla::Vehicle* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestGetManagedActorById(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_InsertVehicle : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_InsertVehicle()
        {
            ::grpc::Service::MarkMethodRaw(4);
        }
        ~WithRawMethod_InsertVehicle() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertVehicle(::grpc::ServerContext* /*context*/, const ::carla::Vehicle* /*request*/, ::carla::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestInsertVehicle(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_GetRandomSpawnPoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_GetRandomSpawnPoint()
        {
            ::grpc::Service::MarkMethodRaw(5);
        }
        ~WithRawMethod_GetRandomSpawnPoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetRandomSpawnPoint(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::Transform* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestGetRandomSpawnPoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_ExecuteOneTimeStep : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_ExecuteOneTimeStep()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(0,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExecuteOneTimeStep(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_ExecuteOneTimeStep() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status ExecuteOneTimeStep(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* ExecuteOneTimeStep(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* ExecuteOneTimeStep(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_Finish : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_Finish()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(1,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Finish(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_Finish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Finish(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* Finish(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* Finish(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_GetManagedActorsIds : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_GetManagedActorsIds()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(2,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetManagedActorsIds(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_GetManagedActorsIds() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedActorsIds(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::ActorIds* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* GetManagedActorsIds(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* GetManagedActorsIds(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_GetManagedActorById : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_GetManagedActorById()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(3,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetManagedActorById(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_GetManagedActorById() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedActorById(::grpc::ServerContext* /*context*/, const ::carla::Number* /*request*/, ::carla::Vehicle* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* GetManagedActorById(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* GetManagedActorById(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_InsertVehicle : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_InsertVehicle()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(4,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InsertVehicle(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_InsertVehicle() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertVehicle(::grpc::ServerContext* /*context*/, const ::carla::Vehicle* /*request*/, ::carla::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* InsertVehicle(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* InsertVehicle(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_GetRandomSpawnPoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_GetRandomSpawnPoint()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(5,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRandomSpawnPoint(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_GetRandomSpawnPoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetRandomSpawnPoint(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::Transform* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* GetRandomSpawnPoint(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* GetRandomSpawnPoint(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_ExecuteOneTimeStep : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_ExecuteOneTimeStep()
        {
            ::grpc::Service::MarkMethodStreamed(0,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::google::protobuf::Empty, ::google::protobuf::Empty>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                    return this->StreamedExecuteOneTimeStep(context,
                    streamer);
                }));
        }
        ~WithStreamedUnaryMethod_ExecuteOneTimeStep() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status ExecuteOneTimeStep(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedExecuteOneTimeStep(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty, ::google::protobuf::Empty>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_Finish : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_Finish()
        {
            ::grpc::Service::MarkMethodStreamed(1,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::google::protobuf::Empty, ::google::protobuf::Empty>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                    return this->StreamedFinish(context,
                    streamer);
                }));
        }
        ~WithStreamedUnaryMethod_Finish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status Finish(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedFinish(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty, ::google::protobuf::Empty>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_GetManagedActorsIds : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_GetManagedActorsIds()
        {
            ::grpc::Service::MarkMethodStreamed(2,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::google::protobuf::Empty, ::carla::ActorIds>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::google::protobuf::Empty, ::carla::ActorIds>* streamer) {
                    return this->StreamedGetManagedActorsIds(context,
                    streamer);
                }));
        }
        ~WithStreamedUnaryMethod_GetManagedActorsIds() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status GetManagedActorsIds(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::ActorIds* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedGetManagedActorsIds(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty, ::carla::ActorIds>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_GetManagedActorById : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_GetManagedActorById()
        {
            ::grpc::Service::MarkMethodStreamed(3,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::carla::Number, ::carla::Vehicle>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::carla::Number, ::carla::Vehicle>* streamer) {
                    return this->StreamedGetManagedActorById(context,
                    streamer);
                }));
        }
        ~WithStreamedUnaryMethod_GetManagedActorById() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status GetManagedActorById(::grpc::ServerContext* /*context*/, const ::carla::Number* /*request*/, ::carla::Vehicle* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedGetManagedActorById(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::carla::Number, ::carla::Vehicle>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_InsertVehicle : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_InsertVehicle()
        {
            ::grpc::Service::MarkMethodStreamed(4,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::carla::Vehicle, ::carla::Number>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::carla::Vehicle, ::carla::Number>* streamer) {
                    return this->StreamedInsertVehicle(context,
                    streamer);
                }));
        }
        ~WithStreamedUnaryMethod_InsertVehicle() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status InsertVehicle(::grpc::ServerContext* /*context*/, const ::carla::Vehicle* /*request*/, ::carla::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedInsertVehicle(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::carla::Vehicle, ::carla::Number>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_GetRandomSpawnPoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_GetRandomSpawnPoint()
        {
            ::grpc::Service::MarkMethodStreamed(5,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::google::protobuf::Empty, ::carla::Transform>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::google::protobuf::Empty, ::carla::Transform>* streamer) {
                    return this->StreamedGetRandomSpawnPoint(context,
                    streamer);
                }));
        }
        ~WithStreamedUnaryMethod_GetRandomSpawnPoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status GetRandomSpawnPoint(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::carla::Transform* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedGetRandomSpawnPoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty, ::carla::Transform>* server_unary_streamer) = 0;
    };
    typedef WithStreamedUnaryMethod_ExecuteOneTimeStep<WithStreamedUnaryMethod_Finish<WithStreamedUnaryMethod_GetManagedActorsIds<WithStreamedUnaryMethod_GetManagedActorById<WithStreamedUnaryMethod_InsertVehicle<WithStreamedUnaryMethod_GetRandomSpawnPoint<Service>>>>>> StreamedUnaryService;
    typedef Service SplitStreamedService;
    typedef WithStreamedUnaryMethod_ExecuteOneTimeStep<WithStreamedUnaryMethod_Finish<WithStreamedUnaryMethod_GetManagedActorsIds<WithStreamedUnaryMethod_GetManagedActorById<WithStreamedUnaryMethod_InsertVehicle<WithStreamedUnaryMethod_GetRandomSpawnPoint<Service>>>>>> StreamedService;
};

}  // namespace carla


#endif  // GRPC_carla_2eproto__INCLUDED
